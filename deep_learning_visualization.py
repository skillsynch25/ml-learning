import matplotlib.pyplot as plt
import seaborn as sns
import numpy as np
from wordcloud import WordCloud
import plotly.express as px
import plotly.graph_objects as go
from sklearn.manifold import TSNE
from sklearn.decomposition import PCA

def plot_training_history(history):
    """
    Plot training and validation metrics
    """
    fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(15, 5))
    
    # Plot accuracy
    ax1.plot(history.history['accuracy'], label='Training Accuracy')
    if 'val_accuracy' in history.history:
        ax1.plot(history.history['val_accuracy'], label='Validation Accuracy')
    ax1.set_title('Model Accuracy')
    ax1.set_xlabel('Epoch')
    ax1.set_ylabel('Accuracy')
    ax1.legend()
    
    # Plot loss
    ax2.plot(history.history['loss'], label='Training Loss')
    if 'val_loss' in history.history:
        ax2.plot(history.history['val_loss'], label='Validation Loss')
    ax2.set_title('Model Loss')
    ax2.set_xlabel('Epoch')
    ax2.set_ylabel('Loss')
    ax2.legend()
    
    return fig

def plot_confusion_matrix(y_true, y_pred, classes):
    """
    Plot confusion matrix
    """
    from sklearn.metrics import confusion_matrix
    cm = confusion_matrix(y_true, y_pred)
    plt.figure(figsize=(10, 8))
    sns.heatmap(cm, annot=True, fmt='d', cmap='Blues',
                xticklabels=classes, yticklabels=classes)
    plt.title('Confusion Matrix')
    plt.ylabel('True Label')
    plt.xlabel('Predicted Label')
    return plt.gcf()

def plot_feature_maps(model, layer_name, input_data):
    """
    Plot feature maps from a CNN layer
    """
    layer_output = model.get_layer(layer_name).output
    feature_map_model = tf.keras.models.Model(inputs=model.input, outputs=layer_output)
    feature_maps = feature_map_model.predict(input_data)
    
    fig, axes = plt.subplots(4, 4, figsize=(15, 15))
    for i, ax in enumerate(axes.flat):
        if i < feature_maps.shape[-1]:
            ax.imshow(feature_maps[0, :, :, i], cmap='viridis')
            ax.axis('off')
    return fig

def plot_word_cloud(texts):
    """
    Generate and plot word cloud
    """
    wordcloud = WordCloud(width=800, height=400, background_color='white').generate(' '.join(texts))
    plt.figure(figsize=(10, 5))
    plt.imshow(wordcloud, interpolation='bilinear')
    plt.axis('off')
    return plt.gcf()

def plot_attention_weights(attention_weights, tokens):
    """
    Plot attention weights
    """
    plt.figure(figsize=(10, 8))
    sns.heatmap(attention_weights, xticklabels=tokens, yticklabels=tokens,
                cmap='YlOrRd', annot=True, fmt='.2f')
    plt.title('Attention Weights')
    return plt.gcf()

def plot_embeddings(embeddings, labels=None):
    """
    Plot embeddings using t-SNE
    """
    tsne = TSNE(n_components=2, random_state=42)
    embeddings_2d = tsne.fit_transform(embeddings)
    
    fig = px.scatter(x=embeddings_2d[:, 0], y=embeddings_2d[:, 1],
                    color=labels if labels is not None else None,
                    title='t-SNE Visualization of Embeddings')
    return fig

def plot_gan_samples(generator, latent_dim, n_samples=16):
    """
    Plot samples generated by GAN
    """
    noise = np.random.normal(0, 1, (n_samples, latent_dim))
    generated_images = generator.predict(noise)
    
    fig, axes = plt.subplots(4, 4, figsize=(10, 10))
    for i, ax in enumerate(axes.flat):
        ax.imshow(generated_images[i], cmap='gray')
        ax.axis('off')
    return fig

def plot_autoencoder_reconstruction(original, reconstructed):
    """
    Plot original and reconstructed images from autoencoder
    """
    fig, axes = plt.subplots(2, 5, figsize=(15, 6))
    for i in range(5):
        axes[0, i].imshow(original[i], cmap='gray')
        axes[0, i].axis('off')
        axes[1, i].imshow(reconstructed[i], cmap='gray')
        axes[1, i].axis('off')
    axes[0, 0].set_ylabel('Original')
    axes[1, 0].set_ylabel('Reconstructed')
    return fig

def plot_model_architecture(model):
    """
    Plot model architecture
    """
    tf.keras.utils.plot_model(model, to_file='model_architecture.png', show_shapes=True)
    return plt.imread('model_architecture.png') 